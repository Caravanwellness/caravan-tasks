import os
import requests
from request import request_vimeo_ott_api 
import time
from dotenv import load_dotenv
# Load environment variables
load_dotenv()

def fetch_texttracks(video_id):
    load_dotenv()

    # Get API key from environment variable
    api_key = os.getenv('VIMEO_API_KEY')
    bearer_token = os.getenv('BEARER_TOKEN')
    """Fetch texttracks for a video from Vimeo API"""

    url = f"https://api.vimeo.com/videos/{video_id}/texttracks"

    headers = {
        'Authorization': 'Bearer ' + bearer_token,
        'Accept': 'application/vnd.vimeo.*+json;version=3.4',
        'X-API-Key': api_key
    }

    all_texttracks = []
    page = 1

    while True:
        params = {"page": page, "per_page": 100}
        response = requests.get(url, headers=headers, params=params)
        time.sleep(5)
        
        if response.status_code != 200:
            print(f"  Error fetching texttracks: {response.status_code}")
            print(f"  Response: {response.text}")
            return None

        data = response.json()
        all_texttracks.extend(data.get("data", []))

        # Check if there are more pages
        paging = data.get("paging", {})
        if not paging.get("next"):
            break

        page += 1

    return all_texttracks

def select_texttrack(texttracks):
    """
    Select the appropriate texttrack based on priority:
    1. language='en' and active=True
    2. language='en-x-autogen' (fallback)
    """
    if not texttracks:
        return None

    # First priority: active English texttracks
    for track in texttracks:
        if track.get("language") == "en" and track.get("active") == True:
            return '', track

    # Fallback: auto-generated English
    for track in texttracks:
        if track.get("language") == "en-x-autogen" and track.get("active") == True:
            return "(autogenerated)", track

    return None

def download_texttracks_vimeo_api(video_id, video_name, row_number):
    """Download texttracks and return list of downloaded language names."""
    downloaded_languages = []
    try:

        texttracks = fetch_texttracks(video_id)

        if texttracks is None:
            print(f"  Failed to fetch texttracks")
            return downloaded_languages

        # Select appropriate texttrack
        autogen, selected_track = select_texttrack(texttracks)

        print(f"  Selected texttrack: Language={selected_track.get('language')}, Type={selected_track.get('type')}, Autogen={autogen}")

        # Check if transcript already exists
        # safe_name = sanitize_filename(video_name)
        # output_path = texttracks_folder / f"{safe_name}{autogen}.vtt"


        link = selected_track.get("link")
        lang = "English"
        language = selected_track.get("language")

        # print(subtitle_files)

        safe_name = "".join(c for c in video_name if c.isalnum() or c in (' ', '-', '_')).strip()
        safe_name = safe_name.replace(' ', '_')
        pathname = f"subtitles/{(row_number + 1):03d}_{safe_name}_subtitles"
        exists = os.path.exists(pathname)

        if not exists:
            os.makedirs(pathname)
            print(f"Created '{pathname}' folder")


        # if not exists:
        print(f"  Downloading texttrack (language: {language})")
    # Download subtitle file
        subtitle_response = requests.get(link, timeout=10)
        subtitle_response.raise_for_status()

        # Save subtitle file
        filename = f"subtitle_{lang}.vtt"
        filepath = os.path.join(pathname, filename)
        with open(filepath, 'wb') as f:
            f.write(subtitle_response.content)
        # print(f"  ✓ Downloaded subtitle: {filename}")
        time.sleep(5)
        downloaded_languages.append(lang)

        return downloaded_languages

    except requests.exceptions.RequestException as e:
        print(f"\n  Error downloading textracks: {e}")
        return downloaded_languages
    except Exception as e:
        print(f"\n  Error processing textrack download: {e}")
        return downloaded_languages


def download_texttracks_vimeo_ott(api_url, video_name, row_number):
    """Download texttracks and return list of downloaded language names."""
    downloaded_languages = []
    try:
        files_data = request_vimeo_ott_api(api_url)
        subtitle_files = files_data['_embedded']['subtitles']
        # print(subtitle_files)

        safe_name = "".join(c for c in video_name if c.isalnum() or c in (' ', '-', '_')).strip()
        safe_name = safe_name.replace(' ', '_')
        pathname = f"subtitles/{(row_number + 1):03d}_{safe_name}_subtitles"
        exists = os.path.exists(pathname)

        if not exists:
            os.makedirs(pathname)
            print(f"Created '{pathname}' folder")

        for subtitle in subtitle_files:
            lang = subtitle.get('language', 'unknown')
            link = subtitle['_links']['self']['href']
            # print(f"  Found subtitle: {lang} - {link}")

            if not exists:
            # Download subtitle file
                subtitle_response = requests.get(link, timeout=10)
                subtitle_response.raise_for_status()

                # Save subtitle file
                filename = f"subtitle_{lang}.srt"
                filepath = os.path.join(pathname, filename)
                with open(filepath, 'wb') as f:
                    f.write(subtitle_response.content)
                # print(f"  ✓ Downloaded subtitle: {filename}")
                time.sleep(2)
            downloaded_languages.append(lang)

        return downloaded_languages

    except requests.exceptions.RequestException as e:
        print(f"\n  Error downloading textracks: {e}")
        return downloaded_languages
    except Exception as e:
        print(f"\n  Error processing textrack download: {e}")
        return downloaded_languages

def update_language_columns(row, downloaded_languages, language_columns):
    """
    For each downloaded language, find its matching column via exact match
    and set to TRUE. If no match, append to the Extras column.
    """
    lang_list = []
    extras_list = []

    for lang in downloaded_languages:
        lang_list.append(lang)
        matched = False
        for col_name in language_columns:
            if lang.lower() == col_name.lower():
                row[col_name] = 'TRUE'
                # print(f"    Matched '{lang}' -> column '{col_name}' = TRUE")
                matched = True
                break
        if not matched:
            if lang not in extras_list:
                extras_list.append(lang)
        
            # print(f"    No column match for '{lang}' -> appended to Extras")

    row['Languages'] = ', '.join(lang_list)
    row['Extras'] = ', '.join(extras_list)
    print(f"    Found Languages: {row['Languages']}")
    print(f"    Updated Extras: {row['Extras']}")
